#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

> 给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。
>
> 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
>
> 注意：你不能在买入股票前卖出股票。
>
> **示例 1:**
>
> ```
> 输入: [7,1,5,3,6,4]
> 输出: 5
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
> 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
> ```
>
> **示例 2:**
>
> ```
> 输入: [7,6,4,3,1]
> 输出: 0
> 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
> ```

**解题思路**

先做的 [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)这题，所以刚开始看的时候还没看出来这两题有什么区别，后来仔细看才发现，这道题 【**只允许完成一笔交易**】，而 122 这题 为了获得最大利润 【**可以尽可能地完成更多的交易（多次买卖一支股票）**】。

回到本题，只允许完成一笔交易，使得利润最大，那就是一个后面的最大值减去一个前面的最小值的问题了。

具体是：

遍历一趟数组，记录数组当前最小值、利润最大值

- 当遍历到的值小于最小值时，更新最小值
- 当遍历到的值大于最小值时，用当前的值减去最小值得到当前利润，再用当前利润和最大利润比较，更新最大利润

最后返回最大利润

**复杂度分析**

一趟遍历 ,所以是O(n)

**代码实现**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min = INT_MAX;
        int maxProfit = 0;
        for(int i=0;i<prices.size();i++) {
            if(prices[i] < min)
                min = prices[i];
            else{
                if( prices[i] - min > maxProfit)
                    maxProfit = prices[i] - min;
            }
        }
        return maxProfit;
    }
};
```

