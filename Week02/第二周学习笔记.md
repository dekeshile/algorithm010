[TOC]



## ç¬¬5è¯¾ | å“ˆå¸Œè¡¨ã€æ˜ å°„ã€é›†åˆ

### çŸ¥è¯†ç‚¹



### å®æˆ˜é¢˜ç›®

#### [242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯](https://leetcode-cn.com/problems/valid-anagram/)

> ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ t ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­ t æ˜¯å¦æ˜¯ s çš„å­—æ¯å¼‚ä½è¯ã€‚
>
> ç¤ºä¾‹ 1:
>
> è¾“å…¥: s = "anagram", t = "nagaram"
> è¾“å‡º: true
>
> ç¤ºä¾‹ 2:
>
> è¾“å…¥: s = "rat", t = "car"
> è¾“å‡º: false
>
> è¯´æ˜:
> ä½ å¯ä»¥å‡è®¾å­—ç¬¦ä¸²åªåŒ…å«å°å†™å­—æ¯ã€‚
>
> è¿›é˜¶:
> å¦‚æœè¾“å…¥å­—ç¬¦ä¸²åŒ…å« unicode å­—ç¬¦æ€ä¹ˆåŠï¼Ÿä½ èƒ½å¦è°ƒæ•´ä½ çš„è§£æ³•æ¥åº”å¯¹è¿™ç§æƒ…å†µï¼Ÿ

```
#define N 26
bool isAnagram(char * s, char * t){
   if(s == NULL || t == NULL)
    return false;
    int hash[N]={0};
    char* ps = s;
    while(*ps != '\0'){
        hash[*ps - 'a']++;
        ps++;
    }
    char* pt = t;
     while(*pt != '\0'){
        hash[*pt - 'a']--;
        pt++;
    }
    for(int i=0;i<N;i++){
        if(hash[i] != 0){
            return false;
        }
    }
    return true;
}
```



#### [49. å­—æ¯å¼‚ä½è¯åˆ†ç»„](https://leetcode-cn.com/problems/group-anagrams/)

> ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œå°†å­—æ¯å¼‚ä½è¯ç»„åˆåœ¨ä¸€èµ·ã€‚å­—æ¯å¼‚ä½è¯æŒ‡å­—æ¯ç›¸åŒï¼Œä½†æ’åˆ—ä¸åŒçš„å­—ç¬¦ä¸²ã€‚
>
> ç¤ºä¾‹:
>
> è¾“å…¥: ["eat", "tea", "tan", "ate", "nat", "bat"]
> è¾“å‡º:
> [
>   ["ate","eat","tea"],
>   ["nat","tan"],
>   ["bat"]
> ]
>
> è¯´æ˜ï¼š
>
> æ‰€æœ‰è¾“å…¥å‡ä¸ºå°å†™å­—æ¯ã€‚
> ä¸è€ƒè™‘ç­”æ¡ˆè¾“å‡ºçš„é¡ºåºã€‚



    #include<map>
    #include<iterator>
    #include<algorithm>
    class Solution {
    public:
        vector<vector<string>> groupAnagrams(vector<string>& strs) {
            map<string,vector<string>> mymap;
            vector<vector<string>> myvec;
            map<string,vector<string>>::iterator it;
            string tempStr;
            for(int i=0;i<strs.size();i++){
                vector<string> temp;
                tempStr = strs[i];
                sort(tempStr.begin(),tempStr.end());
                it = mymap.find(tempStr);
                if(it!=mymap.end()){
                    temp = it->second;
                }
                temp.push_back(strs[i]);
                mymap[tempStr] = temp;
            }
            for(it = mymap.begin();it!=mymap.end();it++){
                myvec.push_back(it->second);
            }
            return myvec;
        }
    };



#### [1. ä¸¤æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/two-sum/)

> ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡ºå’Œä¸ºç›®æ ‡å€¼çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›ä»–ä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚
>
> ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œæ•°ç»„ä¸­åŒä¸€ä¸ªå…ƒç´ ä¸èƒ½ä½¿ç”¨ä¸¤éã€‚
>
> ç¤ºä¾‹:
>
> ç»™å®š nums = [2, 7, 11, 15], target = 9
>
> å› ä¸º nums[0] + nums[1] = 2 + 7 = 9
> æ‰€ä»¥è¿”å› [0, 1]

```
#include<map>
#include<iterator>
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
       //mapçš„ç¬¬ä¸€ä¸ªå…ƒç´ ä»£è¡¨æ•°å€¼ï¼Œç¬¬äºŒä¸ªå…ƒç´ ä»£è¡¨å…¶åœ¨æ•°ç»„ä¸­çš„ä¸‹æ ‡
       map<int,int> mymap;
       vector<int> res;
       for(int i=0;i<nums.size();i++){
            int pair_num  =  target - nums[i];
            if(mymap.find(pair_num) != mymap.end()){
                res.push_back(mymap[pair_num]);
                res.push_back(i);
                return res;
            }
            mymap[nums[i]] = i;
        }
        return res;
    }
};
```





## ç¬¬6-1è¯¾ | æ ‘ã€äºŒå‰æ ‘ã€äºŒå‰æœç´¢æ ‘

### çŸ¥è¯†ç‚¹

### å®æˆ˜é¢˜ç›®

#### [94. äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å®ƒçš„ä¸­åº éå†ã€‚
>
> ç¤ºä¾‹:
>
> è¾“å…¥: [1,null,2,3]
>    1
>     \
>      2
>     /
>    3
>
> è¾“å‡º: [1,3,2]
>
> è¿›é˜¶: é€’å½’ç®—æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥é€šè¿‡è¿­ä»£ç®—æ³•å®Œæˆå—ï¼Ÿ

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderVec;
    vector<int> inorderTraversal(TreeNode* root) {
       inorderVec.clear();
       inorderTra(root);  
       return   inorderVec;
    }
    void inorderTra(TreeNode* root) {
        if(root == NULL)
            return;
        inorderTra(root->left);
        inorderVec.push_back(root->val);
        inorderTra(root->right);
    }
};
```



#### [144. äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å®ƒçš„ *å‰åº* éå†ã€‚

 **ç¤ºä¾‹:**

```
è¾“å…¥: [1,null,2,3]  
   1
    \
     2
    /
   3 

è¾“å‡º: [1,2,3]
```

**è¿›é˜¶:** é€’å½’ç®—æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥é€šè¿‡è¿­ä»£ç®—æ³•å®Œæˆå—ï¼Ÿ

```
class Solution {
public:
    vector<int>  preorderVec;
    vector<int> preorderTraversal(TreeNode* root) {
        preorderVec.clear();
        preorderTra(root);  
       return    preorderVec;
    }
    void  preorderTra(TreeNode* root) {
        if(root == NULL)
            return;
         preorderVec.push_back(root->val);
         preorderTra(root->left);
         preorderTra(root->right);
    }
};
```



#### [590. Nå‰æ ‘çš„ååºéå†](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

> ç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„*ååºéå†*ã€‚
>
> ä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ª `3å‰æ ‘` :
>
>  <img src="%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/narytreeexample.png" alt="img" style="zoom:50%;" />
>
> 
>
>  è¿”å›å…¶ååºéå†: `[5,6,3,2,4,1]`.
>
> **è¯´æ˜:** é€’å½’æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿­ä»£æ³•å®Œæˆæ­¤é¢˜å—?



```
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<int> Vec;
    vector<int> postorder(Node* root) {
       Vec.clear();
       postTra(root);  
       return  Vec;
    }
     void postTra(Node* root) {
        if(root == NULL)
            return;
        for(int i=0;i<root->children.size();i++){
             postTra(root->children[i]);
        }
        Vec.push_back(root->val);
    }
};
```



#### [589. Nå‰æ ‘çš„å‰åºéå†](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

> ç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„*å‰åºéå†*ã€‚
>
> ä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ª `3å‰æ ‘` :
>
> <img src="%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/narytreeexample.png" alt="img" style="zoom:50%;" />
>
>  
>
> è¿”å›å…¶å‰åºéå†: `[1,3,5,6,2,4]`ã€‚
>
> **è¯´æ˜:** é€’å½’æ³•å¾ˆç®€å•ï¼Œä½ å¯ä»¥ä½¿ç”¨è¿­ä»£æ³•å®Œæˆæ­¤é¢˜å—?

```
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/


class Solution {
public:
    vector<int> Vec;
    vector<int> preorder(Node* root) {
       Vec.clear();
       preTra(root);  
       return  Vec;
    }
     void preTra(Node* root) {
        if(root == NULL)
            return;
        Vec.push_back(root->val);            
        for(int i=0;i<root->children.size();i++){
             preTra(root->children[i]);
        }
    }
};
```



#### [429. Nå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

> ç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„*å±‚åºéå†*ã€‚ (å³ä»å·¦åˆ°å³ï¼Œé€å±‚éå†)ã€‚
>
> ä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ª `3å‰æ ‘` :
>
>  
>
> <img src="%E7%AC%AC%E4%BA%8C%E5%91%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/narytreeexample.png" alt="img" style="zoom:50%;" />
>
> è¿”å›å…¶å±‚åºéå†:
>
> ```
> [
>      [1],
>      [3,2,4],
>      [5,6]
> ]
> ```
>
> **è¯´æ˜:**
>
> 1. æ ‘çš„æ·±åº¦ä¸ä¼šè¶…è¿‡ `1000`ã€‚
> 2. æ ‘çš„èŠ‚ç‚¹æ€»æ•°ä¸ä¼šè¶…è¿‡ `5000`ã€‚

```
#include<queue>
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> resVec;
        queue<Node*> myqueue;
        vector<int> layerVec;
        if(root == NULL)
            return resVec;
        myqueue.push(root);
        Node* ele;
        while(!myqueue.empty()){
            vector<int> layerVec;
            for(int layerNums=myqueue.size();0<layerNums;layerNums--){
                ele = myqueue.front();
                for(int i=0;i<ele->children.size();i++){
                    myqueue.push(ele->children[i]);
                 }
                layerVec.push_back(ele->val);
                myqueue.pop();
            }
            resVec.push_back(layerVec);
        }  
        return resVec;
    }
};
```





## å †å’ŒäºŒå‰å †

### å®æˆ˜é¢˜ç›®

#### [é¢è¯•é¢˜40. æœ€å°çš„kä¸ªæ•°](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

> è¾“å…¥æ•´æ•°æ•°ç»„ `arr` ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€å°çš„ `k` ä¸ªæ•°ã€‚ä¾‹å¦‚ï¼Œè¾“å…¥4ã€5ã€1ã€6ã€2ã€7ã€3ã€8è¿™8ä¸ªæ•°å­—ï¼Œåˆ™æœ€å°çš„4ä¸ªæ•°å­—æ˜¯1ã€2ã€3ã€4ã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šarr = [3,2,1], k = 2
> è¾“å‡ºï¼š[1,2] æˆ–è€… [2,1]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šarr = [0,1,2,1], k = 1
> è¾“å‡ºï¼š[0]
> ```
>
> **é™åˆ¶ï¼š**
>
> - `0 <= k <= arr.length <= 10000`
> - `0 <= arr[i] <= 10000`

```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
#include<stdlib.h>

void swap(int* aa,int* bb){
    int temp = *aa;
    *aa = *bb;
    *bb = temp;
}

//påŠå…¶å­©å­ä¸­,å€¼æœ€å°è€…çš„ä¸‹æ ‡
int getMin(int a[],int n,int p)
{
    int lc = p*2 + 1 ;
    int rc = p*2 + 2 ;
    int _min,smaller;
    if(rc < n) //æœ‰å·¦å³å­©å­
    {
        smaller = a[lc] < a[rc] ? lc:rc;
        _min = a[smaller] < a[p] ? smaller:p;
    }else{
        if(lc < n)//åªæœ‰å·¦å­©å­
        {
             _min = a[lc] < a[p] ? lc:p;
        }else{//æ²¡æœ‰å·¦å³å­©å­
            _min = p;
        }
    }
    return _min;
}
//å•ä¸ªç»“ç‚¹çš„ä¸‹æ»¤æ“ä½œ
int perDownFilter(int a[],int n,int i)
{
    int j;//iåŠå…¶å­©å­ä¸­å€¼æœ€å°è€…ä¸‹æ ‡
    while( i != (j = getMin(a,n,i)))//å½“ i = jæ—¶ï¼Œå³ä¸‹é¢ä¸å†éœ€è¦è°ƒæ•´
    {
        swap(&a[i],&a[j]);//äº¤æ¢ä¸¤è€…ï¼Œå¹¶ç»§ç»­è€ƒå¯Ÿä¸‹é™åçš„i
        i = j;

    }
    return i; //è¿”å›ä¸‹æ»¤æ“ä½œæŠµè¾¾çš„æœ€æ·±çš„ç»ˆç»“ä½ç½®(äº¦iäº¦j)
}

void createHeap(int a[],int n)
{
    int cnt =0;
    for(int i = (n-2)/2;i>=0;i-- )
    {
        perDownFilter(a,n,i);//ä¸‹æ»¤å†…éƒ¨ç»“ç‚¹
    }
}

int getHeapTop(int a[],int* n){
    if(a == NULL || *n <= 0)
        return 0;
    int res = a[0];
    a[0] = a[*n-1];//å°†æœ€åä¸€ä¸ªå…ƒç´ æ”¾åˆ°å †é¡¶
    perDownFilter(a,*n-1,0);//é‡æ–°è°ƒæ•´å †
    *n = *n-1;
    return res;
}

int* getLeastNumbers(int* arr, int arrSize, int k, int* returnSize){
    int* res = (int*)malloc(sizeof(int)*k);
    createHeap(arr,arrSize);
    int* heapSize = &arrSize;

    for(int i=0;i<k;i++){
        res[i] = getHeapTop(arr,heapSize);
    }
    *returnSize = k;
    return res;
}
```



#### [239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼](https://leetcode-cn.com/problems/sliding-window-maximum/)

> ç»™å®šä¸€ä¸ªæ•°ç»„ *nums*ï¼Œæœ‰ä¸€ä¸ªå¤§å°ä¸º *k* çš„æ»‘åŠ¨çª—å£ä»æ•°ç»„çš„æœ€å·¦ä¾§ç§»åŠ¨åˆ°æ•°ç»„çš„æœ€å³ä¾§ã€‚ä½ åªå¯ä»¥çœ‹åˆ°åœ¨æ»‘åŠ¨çª—å£å†…çš„ *k* ä¸ªæ•°å­—ã€‚æ»‘åŠ¨çª—å£æ¯æ¬¡åªå‘å³ç§»åŠ¨ä¸€ä½ã€‚
>
> è¿”å›æ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼ã€‚
>
> **è¿›é˜¶ï¼š**
>
> ä½ èƒ½åœ¨çº¿æ€§æ—¶é—´å¤æ‚åº¦å†…è§£å†³æ­¤é¢˜å—ï¼Ÿ
>
> **ç¤ºä¾‹:**
>
> ```
> è¾“å…¥: nums = [1,3,-1,-3,5,3,6,7], å’Œ k = 3
> è¾“å‡º: [3,3,5,5,6,7] 
> è§£é‡Š: 
> 
>   æ»‘åŠ¨çª—å£çš„ä½ç½®                æœ€å¤§å€¼
> ---------------               -----
> [1  3  -1] -3  5  3  6  7       3
>  1 [3  -1  -3] 5  3  6  7       3
>  1  3 [-1  -3  5] 3  6  7       5
>  1  3  -1 [-3  5  3] 6  7       5
>  1  3  -1  -3 [5  3  6] 7       6
>  1  3  -1  -3  5 [3  6  7]      7
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= nums.length <= 10^5`
> - `-10^4 <= nums[i] <= 10^4`
> - `1 <= k <= nums.length`

```
//æ³¨æ„ä¿ç•™ä¸Šä¸€æ¬¡çš„æœ€å¤§å’Œæœ€æ–°ä¸€æ¬¡çª—å£è¿›æ¥çš„é‚£ä¸ªå…ƒç´ åšæ¯”è¾ƒå³å¯
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
         vector<int> res;
         if(k > nums.size())
            return res;
        int max = getMax(nums,0,k-1);
        res.push_back(max);
        for(int i=1;i<nums.size()&&i+k<=nums.size();i++){
            //åˆ¤æ–­è¿™ä¸ªmaxæ˜¯ä¸æ˜¯çª—å£æ»‘åŠ¨æ‰çš„å…ƒç´ ï¼Œæ˜¯çš„è¯å°±è¦è°ƒç”¨getMaxäº†
            max = ( max == nums[i-1] ? getMax(nums,i,i+k-1) : 
                         ( nums[i+k-1] > max ?  nums[i+k-1] : max) 
                     ) ;
           res.push_back(max);
        }
        return res;
    }
    #åœ¨åŒºé—´ [left,right]é‡Œæ‰¾æœ€å¤§å€¼ O(n)
    int getMax(vector<int>& nums,int left,int right){
        int max = nums[left];
        for(int i=left;i<=right;i++){
            max = nums[i] > max ? nums[i]:max;
        }
        return max;
    }
};
```





#### [347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode-cn.com/problems/top-k-frequent-elements/)

> ç»™å®šä¸€ä¸ªéç©ºçš„æ•´æ•°æ•°ç»„ï¼Œè¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ ***k\*** é«˜çš„å…ƒç´ ã€‚
>
> **ç¤ºä¾‹ 1:**
>
> ```
> è¾“å…¥: nums = [1,1,1,2,2,3], k = 2
> è¾“å‡º: [1,2]
> ```
>
> **ç¤ºä¾‹ 2:**
>
> ```
> è¾“å…¥: nums = [1], k = 1
> è¾“å‡º: [1]
> ```
>
> **æç¤ºï¼š**
>
> - ä½ å¯ä»¥å‡è®¾ç»™å®šçš„ *k* æ€»æ˜¯åˆç†çš„ï¼Œä¸” 1 â‰¤ k â‰¤ æ•°ç»„ä¸­ä¸ç›¸åŒçš„å…ƒç´ çš„ä¸ªæ•°ã€‚
> - ä½ çš„ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦**å¿…é¡»**ä¼˜äº O(*n* log *n*) , *n* æ˜¯æ•°ç»„çš„å¤§å°ã€‚
> - é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆå”¯ä¸€ï¼Œæ¢å¥è¯è¯´ï¼Œæ•°ç»„ä¸­å‰ k ä¸ªé«˜é¢‘å…ƒç´ çš„é›†åˆæ˜¯å”¯ä¸€çš„ã€‚
> - ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚

```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 #include<stdlib.h>
 #include<stdio.h>
 #define N 10000
 #define OFFSITE 5000

struct Node{
    int data;
    int num;
};
struct Node countFre[N];

int cmp ( const void *a , void *b){
        struct Node *na = ( struct Node *)a;
        struct Node *nb = ( struct Node *)b;
        return nb->num - na->num;
}

int* topKFrequent(int* nums, int numsSize, int k, int* returnSize){
    //åˆå§‹åŒ–countFre
      memset(countFre,0,sizeof(struct Node)*N);
      int index;
      for(int i=0;i<numsSize;i++){
          index = (nums[i]+ OFFSITE)%N;
          countFre[index].num++;
          countFre[index].data = nums[i];
      }
      //å°†countFreåšç´§å‡‘
      int j=0;
      for(int i=0;i<N;i++){
          if(countFre[i].num != 0){
              countFre[j++] = countFre[i];
          }
      }
      qsort(countFre,j,sizeof(countFre[0]),&cmp);
      int* res = (int*)malloc(sizeof(int)*k);
      for(int i=0;i<k;i++){
          res[i] = countFre[i].data;
      }
      *returnSize = k;
      return res;
}
```









## ä¸‹å‘¨é¢„ä¹ 

### é¢„ä¹ é¢˜ç›®ï¼š

- ğŸ”²[çˆ¬æ¥¼æ¢¯](https://leetcode-cn.com/problems/climbing-stairs/)
- ğŸ”²[æ‹¬å·ç”Ÿæˆ](https://leetcode-cn.com/problems/generate-parentheses/)
- ğŸ”²[ Pow(x, n) ](https://leetcode-cn.com/problems/powx-n/)
- ğŸ”²[å­é›†](https://leetcode-cn.com/problems/subsets/)
- ğŸ”²[ N çš‡å](https://leetcode-cn.com/problems/n-queens/)