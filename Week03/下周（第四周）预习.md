**目录**
- [预习题目](#预习题目)
  - [102. 二叉树的层序遍历](#102-二叉树的层序遍历)
  - [455. 分发饼干](#455-分发饼干)
  - [122. 买卖股票的最佳时机 II](#122-买卖股票的最佳时机-ii)
  - [55. 跳跃游戏](#55-跳跃游戏)
  - [69. x 的平方根](#69-x-的平方根)
  - [367. 有效的完全平方数](#367-有效的完全平方数)



# 预习题目

## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 

> **示例：**
>  二叉树：`[3,9,20,null,null,15,7]`,
>
> ```
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```
>
> 返回其层次遍历结果：
>
> ```
> [
>   [3],
>   [9,20],
>   [15,7]
> ]
> ```

**解题思路**

本题和第二周的 [429. N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/) 其实几乎是同一个题，二叉树的层次遍历只是N叉树层序遍历的一种特殊情况。除了需要层次遍历以外，本题还要求打印出每层所包含的结点。普通的层序遍历每次从队列中取出一个结点，并将其踢出队列，然后将该结点的所有子结点push到队列中。

如果简单模拟下这个过程：

    	 3
      /    \
      9     20
     / \    / \
    6   8  15  7  
一开始将root结点3入队                                  |    3所在层数为1，操作完后队列中元素个数为1个 `[ 3 ]`

取出队首元素3，将其子结点9和20入队        |     9和20所在层数为2，操作完后队列中元素个数为2个 `[ 9 20]`

取出队首元素9，将其子结点 6和 8 入队       |    6和8所在层数为3，操作完后队列中元素个数为3个 `[  20 6 8 ]`

取出队首元素20，将其子结点 15和 7 入队   |   15和7所在层数为3，操作完后队列中元素个数为4个  `[  6 8 15 7 ]`

………………..

当遍历9和20时，9和20是同一层的结点，其实是要分别取出它们，并把它们的孩子结点push到队列中的，而它们的孩子结点其实是同一层的，所以我们可以在不断从队列中[取结点push子结点]这个操作之前控制这部分结点是同层结点。怎么知道哪些是同层结点呢，在上面的例子中，在操作完[取队首3，push孩子9和20]后，队列的个数变为2个，而它们两个就是同层结点，我们记录此时队列的大小，即是这层的结点个数，循环遍历每个结点把它们的孩子push到队列中，而两个结点都操作完之后此时队列结点个数为4，是第三层。记录此时队列数，重复上面的操作………..

每层我们所记录的队列中结点个数（同层个数），其实就是来源于上一层所有结点作完操作之后队列里面的结点个数，具体看如下核心代码

```
  while(!que.empty()){
      vector<int> layer;//记录同层结点
      /*que.size()来自上一层结点把所有子结点入队后的结点个数 */
      for(int i=que.size();0<i;i--){
      	TreeNode* top = que.front();
      	que.pop();//去掉当层此结点
      	if(top->left != NULL)
      	que.push(top->left);//入下层左孩子
      	if(top->right != NULL)
      	que.push(top->right);//下层右孩子
      	layer.push_back(top->val);
      }
      res.push_back(layer);
 }
```

**完整代码实现**

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 /*
      3
   /    \
  9     20
 / \    / \
6   8  15  7  

 */
 #include<queue>
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        if(root != NULL)
            que.push(root);
        while(!que.empty()){
            vector<int> layer;
        /*此处不可以为 for(int i=0;i<que.size();i++) 
        因为这样que.size()会随着上次循环的push操作而动态变化*/
            for(int i=que.size();0<i;i--){
                TreeNode* top = que.front();
                que.pop();
                if(top->left != NULL)
                    que.push(top->left);
                if(top->right != NULL)
                    que.push(top->right);
                layer.push_back(top->val);
            }
            res.push_back(layer);
        }
        return res;
    }
};
```



## [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>
> **注意：**
>
> 你可以假设胃口值为正。
>  一个小朋友最多只能拥有一块饼干。
>
> **示例 1:**
>
> ```
> 输入: [1,2,3], [1,1]
> 
> 输出: 1
> 
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。
> ```
>
> **示例 2:**
>
> ```
> 输入: [1,2], [1,2,3]
> 
> 输出: 2
> 
> 解释: 
> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
> 你拥有的饼干数量和尺寸都足以让所有孩子满足。
> 所以你应该输出2.
> ```

**代码实现**

```

```



## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

> 给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
> **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> **示例 1:**
>
> ```
> 输入: [7,1,5,3,6,4]
> 输出: 7
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
> ```
>
> **示例 2:**
>
> ```
> 输入: [1,2,3,4,5]
> 输出: 4
> 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
>      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
> ```
>
> **示例 3:**
>
> ```
> 输入: [7,6,4,3,1]
> 输出: 0
> 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
> ```
>
> **提示：**
>
> - `1 <= prices.length <= 3 * 10 ^ 4`
> - `0 <= prices[i] <= 10 ^ 4`

**代码实现**

```

```



## [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

> 给定一个非负整数数组，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个位置。
>
> **示例 1:**
>
> ```
> 输入: [2,3,1,1,4]
> 输出: true
> 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
> ```
>
> **示例 2:**
>
> ```
> 输入: [3,2,1,0,4]
> 输出: false
> 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
> ```

**代码实现**

```

```



## [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

> 实现 `int sqrt(int x)` 函数。
>
> 计算并返回 *x* 的平方根，其中 *x* 是非负整数。
>
> 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
>
> **示例 1:**
>
> ```
> 输入: 4
> 输出: 2
> ```
>
> **示例 2:**
>
> ```
> 输入: 8
> 输出: 2
> 说明: 8 的平方根是 2.82842..., 
>      由于返回类型是整数，小数部分将被舍去。
> ```

**代码实现**

```

```



## [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

> 给定一个正整数 *num*，编写一个函数，如果 *num* 是一个完全平方数，则返回 True，否则返回 False。
>
> **说明：**不要使用任何内置的库函数，如 `sqrt`。
>
> **示例 1：**
>
> ```
> 输入：16
> 输出：True
> ```
>
> **示例 2：**
>
> ```
> 输入：14
> 输出：False
> ```

**代码实现**

```

```

